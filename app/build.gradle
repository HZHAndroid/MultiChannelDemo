plugins {
    id 'com.android.application'
    id 'kotlin-android'
}

apply from: "../app_config.gradle"

// 参考：https://blog.csdn.net/abc6368765/article/details/52786509/

//打包时间
def releaseTime() {
    return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC"))
}

//获取local.properties的内容
Properties properties = new Properties()
properties.load(project.rootProject.file('local.properties').newDataInputStream())

android {
    compileSdk 30
    buildToolsVersion "30.0.3"

    // 使用签名文件进行签名的两种方式
//    //第一种：使用gradle直接签名打包
//    signingConfigs {
//        config {
//            storeFile file('keyTest.jks')
//            storePassword '123456'
//            keyAlias 'HomeKey'
//            keyPassword '123456'
//        }
//    }
    //第二种：为了保护签名文件，把它放在local.properties中并在版本库中排除
    // ，不把这些信息写入到版本库中（注意，此种方式签名文件中不能有中文）
    // 在 signingConfigs 可以配置多个签名配置，加入不同渠道签名不同
    signingConfigs {
        config {
            storeFile file(properties.getProperty("keystroe_storeFile"))
            storePassword properties.getProperty("keystroe_storePassword")
            keyAlias properties.getProperty("keystroe_keyAlias")
            keyPassword properties.getProperty("keystroe_keyPassword")
        }
    }

    // 默认配置
    defaultConfig {
        // 这里配置到下面的渠道里去，方便定制，加入属性相同，依旧放在这里也可以的
//        applicationId "com.young.multichanneldemo"
        minSdk 21
        targetSdk 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

//    buildTypes {
//        release {
//            minifyEnabled false
//            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
//        }
//    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = '1.8'
    }

    //移除lint检测的error
    lintOptions {
        abortOnError false
    }

    sourceSets {
//        main {
//            jniLibs.srcDirs = ['libs']
//        }
        // young 这里新增指定prd环境的资源文件，也就是这里的文件会覆盖 res 的同名文件
        // 这里的 prod.res.srcDirs 中的 prod 是渠道名称
        // 然后这里指向的资源路径，是渠道特有的资源，总而言之，就是这里的资源会覆盖，正常 res 目录下的资源
        prod.res.srcDirs = ['src/main/res-prod']
        uat.res.srcDirs = ['src/main/res-uat']
    }

    // 定义一个纬度
    // https://www.bbsmax.com/A/nAJvvg03Jr/
    // 解决 All flavors must now belong to a named flavor dimension
    // 其实定义多个纬度后，就说会用第一个纬度的，分别跟第二个纬度以及后面的纬度进行组合
    //例如：
    //flavorDimensions "api", "mode"
    // 那么组合就是: api + mode 的各种组合
    flavorDimensions "main"


    // 配置多渠道打包
    // 在 productFlavors 中配置多少个渠道，最后打包就有多少个渠道可以选择打包
    // defaultConfig{} 可以配置的，都可以在渠道里配置
    // 这里指定了渠道之后，原本的 debug 和 release 渠道就不存在了
    productFlavors {
        // 这个渠道叫 prod
        prod {
            // 每个环境包名可以指定不同
            applicationId envInfo.prod.applicationId
            versionCode envInfo.prod.versionCode
            versionName envInfo.prod.versionName
            flavorDimensions "main"

            // 修改 AndroidManifest.xml 里渠道变量
            manifestPlaceholders = [app_icon: "@mipmap/logo"]

            // 动态添加 string.xml 字段；
            // 注意，这里是添加，在 string.xml 不能有这个字段，会重名！！！
            // 这里不建议这样添加，因为国际化的时候这里没办法处理
            // 所以假如真的需要覆盖，则在 sourceSets {} 中指定的资源路径，去覆盖资源实现
//            resValue "string", "app_name", "百度"
//            resValue "bool", "auto_updates", 'false'
            // 动态修改 常量 字段
//            buildConfigField "String", "ENVIRONMENT", '"我是百度首页"'
            buildConfigField "String", "ENVIRONMENT", "\"${envInfo.prod.host}\""
        }
        // 这个渠道叫 uat
        uat {
            applicationId envInfo.uat.applicationId
            versionCode envInfo.uat.versionCode
            versionName envInfo.uat.versionName
            flavorDimensions "main"
            manifestPlaceholders = [app_icon: "@mipmap/logo"]
            buildConfigField "String", "ENVIRONMENT", "\"${envInfo.uat.host}\""
        }
    }

    // 这里是打包方式，指定不同的签名方式、混淆逻辑等
    // buildTypes 指定多少个打包方式（debug、release）
    // 那么 productFlavors {} 的每个管道，都会对应多少个结果包
    // 例如：
    // prod管道，就会有：prodDebug、prodRelease、 prodAlpha等结果包
    // uat管道，就会有：uatDebug、uatRelease、uatAlpha 等结果包
    buildTypes {
        debug {
            // 使用config签名(这个配置虽然可以放到 productFlavors{} 的管道中，但是debug包的话，签名配置不会被覆盖，
            // 也就是会使用系统默认的签名文件，但是配置在 buildTypes{} 这里，就不会使用系统默认的，而是使用我们指定的)
            signingConfig signingConfigs.config

            // debug模式下，显示log
            buildConfigField("boolean", "LOG_DEBUG", "true")

            //为已经存在的applicationId添加后缀(就说变成不同的包名了)
            applicationIdSuffix ".debug"
            // 为版本名添加后缀
            versionNameSuffix "-debug"
            // 不开启混淆
            minifyEnabled false
            // 不开启ZipAlign优化
            zipAlignEnabled false
            // 不移除无用的resource文件
            shrinkResources false
        }

        release {
            // 使用config签名
            signingConfig signingConfigs.config

            // release模式下，不显示log
            buildConfigField("boolean", "LOG_DEBUG", "false")
            // 为版本名添加后缀
            versionNameSuffix "-relase"
            // 不开启混淆
            minifyEnabled true
            // 开启ZipAlign优化
            zipAlignEnabled true
            // 移除无用的resource文件
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }

        alpha {
            // 使用config签名
            signingConfig signingConfigs.config

            // debug模式下，显示log
            buildConfigField("boolean", "LOG_DEBUG", "true")

            //为已经存在的applicationId添加后缀
            applicationIdSuffix ".alpha"
            // 为版本名添加后缀
            versionNameSuffix "-alpha"
            // 不开启混淆
            minifyEnabled false
            // 不开启ZipAlign优化
            zipAlignEnabled false
            // 不移除无用的resource文件
            shrinkResources false
        }

        // 这部分是 as  3.0 以下的
//        // 批量打包
//        applicationVariants.all { variant ->
//            variant.outputs.each { output ->
//                def outputFile = output.outputFile
//                println("outputFile = ${outputFile}")
//                if (outputFile != null && outputFile.name.endsWith('.apk')) {
//                    //输出apk名称为：渠道名_版本名_时间.apk
//                    def fileName = "${variant.productFlavors[0].name}_v${defaultConfig.versionName}_${releaseTime()}.apk"
//                    output.outputFile = new File(outputFile.parent, fileName)
//                }
//            }
//        }
        // as 3.0 以上的
        // https://blog.csdn.net/qq_36317441/article/details/81625936

        applicationVariants.all { variant ->
            variant.outputs.all { output ->
                def outputFile = output.outputFile
                if (outputFile != null && outputFile.name.endsWith('.apk')) {
                    // https://blog.csdn.net/h_bpdwn/article/details/108385118
                    // https://blog.csdn.net/u014780554/article/details/81284330
                    /*指定输出到 ${project}/outputs/apk/release文件夹下*/
                    // young 不建议更改，更改之后直接运行，会运行之后看不到 app
                    //variant.getPackageApplication().outputDirectory = new File(project.rootDir.absolutePath + "/outputs/apk/release")
//                    variant.getPackageApplication().outputDirectory = new File(project.rootDir.absolutePath + File.separator + "app" + File.separator + "outputs" +
//                            File.separator + variant.flavorName + File.separator + variant.buildType.name)
                    // 指定 apk 的输出路径
                    //输出apk名称为：渠道名_版本名_时间.apk
//                    def fileName = "${variant.productFlavors[0].name}_v${defaultConfig.versionName}_${releaseTime()}.apk"
//                    def fileName = "${variant.productFlavors[0].name}_v${variant.productFlavors[0].versionName}_${releaseTime()}.apk"
                    def fileName = "${variant.flavorName}-${variant.buildType.name}_v${variant.productFlavors[0].versionName}_b${variant.productFlavors[0].versionCode}_${releaseTime()}.apk"
                    outputFileName = fileName
                }
            }

//            // https://blog.csdn.net/smallbabylong/article/details/111276762
//            // 打包完成后做的一些事,复制apk到指定文件夹,复制mapping等
//            variant.assemble.doLast {
//                String oldApkOutDirPath = rootDir.absolutePath + File.separator + "app" + File.separator + variant.flavorName
//                deleteDir(new File(oldApkOutDirPath))
//            }
        }

    }


}

/**
 * 删除目录
 * @param file 需要删除的目录
 * @return
 */
def deleteDir(File file) {
    if (!file.exists()) {
        return
    }
    if (file.isFile()) {
        file.delete()
        return
    }
    if (file.isDirectory()) {
        File[] fileList = file.listFiles()
        if (fileList == null || fileList.length == 0) {
            file.delete()
            return
        }
        for (File f : fileList) {
            deleteDir(f)
        }
        file.delete()
    }
}

dependencies {

    implementation 'androidx.core:core-ktx:1.6.0'
    implementation 'androidx.appcompat:appcompat:1.3.1'
    implementation 'com.google.android.material:material:1.4.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.0'
    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
}